{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Guy Guy is a python3 module to make a simple GUI for your python3 script, using html/js/css technologies (a little bit like electron ). It borrows the idea from python-eel , but provide a lot more things. The main idea, is to reuse the installed chrome app on the host. So your script (or your freezed app) stays at the minimal footprint. But your user needs to have Chrome (or chromium) on its computer, to run your script/app. If you want to release a standalone/freezed app, with all included (your script + a chrome container). You can use a special mode with cefpython3 . But the footprint will be around 60mo (like an electron app). But you can ;-) There are 3 modes to release your app : app : your user will need to have a chrome instance. The GUI will be handled by a chrome instance, runned in \"app mode\". (on android/ios, the GUI will be handled by webViewClient/kivy) cef : (stands for cefpython3): All is embedded, it's the embedded cef instance which will handle your GUI. server : it will act as an http server, and any browsers can handle your GUI. So, there can be multiple clients ! Like you understand, your GUI should be built with HTML/JS/CSS. Under the hood, guy provides a simple mechanisms (with websockets) to interact with the python technologies. Your GUI can be native HTML/JS/CSS or any modern js frameworks : vuejs, angular, react, etc ... The app mode can be runned on an Android device, using kivy/buildozer toolchain (for building an apk). Understand that the same app can be runned on any android devices or on any computer (win, mac, *nix ...), without any modifications. Main goal With guy , you can provide quickly a frontend for your tool. When freezed, the minimal size is nearly 6mo (under windows10). Your users can use it, as is (if they've got chrome installed).","title":"Introduction"},{"location":"#guy","text":"Guy is a python3 module to make a simple GUI for your python3 script, using html/js/css technologies (a little bit like electron ). It borrows the idea from python-eel , but provide a lot more things. The main idea, is to reuse the installed chrome app on the host. So your script (or your freezed app) stays at the minimal footprint. But your user needs to have Chrome (or chromium) on its computer, to run your script/app. If you want to release a standalone/freezed app, with all included (your script + a chrome container). You can use a special mode with cefpython3 . But the footprint will be around 60mo (like an electron app). But you can ;-) There are 3 modes to release your app : app : your user will need to have a chrome instance. The GUI will be handled by a chrome instance, runned in \"app mode\". (on android/ios, the GUI will be handled by webViewClient/kivy) cef : (stands for cefpython3): All is embedded, it's the embedded cef instance which will handle your GUI. server : it will act as an http server, and any browsers can handle your GUI. So, there can be multiple clients ! Like you understand, your GUI should be built with HTML/JS/CSS. Under the hood, guy provides a simple mechanisms (with websockets) to interact with the python technologies. Your GUI can be native HTML/JS/CSS or any modern js frameworks : vuejs, angular, react, etc ... The app mode can be runned on an Android device, using kivy/buildozer toolchain (for building an apk). Understand that the same app can be runned on any android devices or on any computer (win, mac, *nix ...), without any modifications. Main goal With guy , you can provide quickly a frontend for your tool. When freezed, the minimal size is nearly 6mo (under windows10). Your users can use it, as is (if they've got chrome installed).","title":"Guy"},{"location":"anatomy/","text":"Anatomy : how it works A guy's app can be seen as a single application. It could be true for app & cef mode. Under the hood : it's basically 2 things: Server Side : An http & socket server Client Side : A javascript lib which make the glue with the server. For app & cef mode : guy run the two in a windowed app. (there is one server & one client) For server mode : guy run the server, and a classical browser can be a client, when connected. (there is one server & many clients) In all cases : the http server serve the client as a html component. And the client communicate with the server with a websocket. Info Although there is always a http server running, under the hood. Only the one in server mode is listening wide (0.0.0.0) to accept connections from all the world ;-). Thoses in app/cef mode are listening on localhost only (can't accept connections from another computer) Technically : it's the marvellous tornado , an asynchronous networking library which handle http & socket. So guy can work for python >= 3.5 (ready for raspberry pi !)","title":"Anatomy"},{"location":"anatomy/#anatomy-how-it-works","text":"A guy's app can be seen as a single application. It could be true for app & cef mode. Under the hood : it's basically 2 things: Server Side : An http & socket server Client Side : A javascript lib which make the glue with the server. For app & cef mode : guy run the two in a windowed app. (there is one server & one client) For server mode : guy run the server, and a classical browser can be a client, when connected. (there is one server & many clients) In all cases : the http server serve the client as a html component. And the client communicate with the server with a websocket. Info Although there is always a http server running, under the hood. Only the one in server mode is listening wide (0.0.0.0) to accept connections from all the world ;-). Thoses in app/cef mode are listening on localhost only (can't accept connections from another computer) Technically : it's the marvellous tornado , an asynchronous networking library which handle http & socket. So guy can work for python >= 3.5 (ready for raspberry pi !)","title":"Anatomy : how it works"},{"location":"client/","text":"Client side : guy.js Not like the good old wuy ; javascript's apis are in two objetcs : guy : to handle the core of guy. self : to handle the declared methods in the guy's class, on server side Guy's apis guy.init( function() { ... } ) Will run the function when everything is started. It's a good place to start your logic. BTW, since >=0.4.3 ... it's a better practice to call a js method, from py side, to start your logic ... like this : class Example ( Guy ): \"\"\" <script> function start() { // .... } </script> \"\"\" async def init ( self ): await self . js . start () guy.on( event, function(arg1, arg2, ...) { ... } ) To listen to an event ... It returns a method to unsubscribe the listenner. guy.emit( event, arg1, arg2, ...) To emit an event to all connected clients. It's a non-sense in app or cef mode : because there is only one client. It only got sense in server mode. guy.emitMe( event, arg1, arg2, ...) To emit an event to the current client (only me;-)). guy.fetch( url, options ) Same as window.fetch , but it's the server which will do the request, to avoid CORS issues. guy.exit( returnValue=None ) Exit the app. If you want to get a \"returnValue\", you can set here the returned value, in py side: myapp = MyGuyApp () returnValue = myapp . run () async guy.cfg A place to get/set vars, which will be stored on server side, in a config.json file, where the main executable is runned. (if the guy'app is embedded in a pip/package, the config file will be stored in `~/.<package_name>.json ) To set a var 'name', in js side : guy . cfg . name = \"Elton\" ; To get a var 'name', in js side : var name = await guy . cfg . name ; Self's apis It's all the apis which have been defined in the class instance. If you have a class like that, on py side: class Simple ( Guy ): \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" def test ( self ): print ( \"hello world\" ) You wil have a self.test() method in client side ! Theses methods can be sync or async, depending on your need. self.exit( returnValue=None ) Exit the current instance, if it's the main instance : it quits the app. If you want to get a \"returnValue\", you can set the returned value, which will be returned in py side: myapp = MyGuyApp () returnValue = myapp . run ()","title":"Client side"},{"location":"client/#client-side-guyjs","text":"Not like the good old wuy ; javascript's apis are in two objetcs : guy : to handle the core of guy. self : to handle the declared methods in the guy's class, on server side","title":"Client side : guy.js"},{"location":"client/#guys-apis","text":"","title":"Guy's apis"},{"location":"client/#guyinit-function","text":"Will run the function when everything is started. It's a good place to start your logic. BTW, since >=0.4.3 ... it's a better practice to call a js method, from py side, to start your logic ... like this : class Example ( Guy ): \"\"\" <script> function start() { // .... } </script> \"\"\" async def init ( self ): await self . js . start ()","title":"guy.init( function() { ... } )"},{"location":"client/#guyon-event-functionarg1-arg2","text":"To listen to an event ... It returns a method to unsubscribe the listenner.","title":"guy.on( event, function(arg1, arg2, ...) { ... } )"},{"location":"client/#guyemit-event-arg1-arg2","text":"To emit an event to all connected clients. It's a non-sense in app or cef mode : because there is only one client. It only got sense in server mode.","title":"guy.emit( event, arg1, arg2, ...)"},{"location":"client/#guyemitme-event-arg1-arg2","text":"To emit an event to the current client (only me;-)).","title":"guy.emitMe( event, arg1, arg2, ...)"},{"location":"client/#guyfetch-url-options","text":"Same as window.fetch , but it's the server which will do the request, to avoid CORS issues.","title":"guy.fetch( url, options )"},{"location":"client/#guyexit-returnvaluenone","text":"Exit the app. If you want to get a \"returnValue\", you can set here the returned value, in py side: myapp = MyGuyApp () returnValue = myapp . run ()","title":"guy.exit( returnValue=None )"},{"location":"client/#async-guycfg","text":"A place to get/set vars, which will be stored on server side, in a config.json file, where the main executable is runned. (if the guy'app is embedded in a pip/package, the config file will be stored in `~/.<package_name>.json ) To set a var 'name', in js side : guy . cfg . name = \"Elton\" ; To get a var 'name', in js side : var name = await guy . cfg . name ;","title":"async guy.cfg"},{"location":"client/#selfs-apis","text":"It's all the apis which have been defined in the class instance. If you have a class like that, on py side: class Simple ( Guy ): \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" def test ( self ): print ( \"hello world\" ) You wil have a self.test() method in client side ! Theses methods can be sync or async, depending on your need.","title":"Self's apis"},{"location":"client/#selfexit-returnvaluenone","text":"Exit the current instance, if it's the main instance : it quits the app. If you want to get a \"returnValue\", you can set the returned value, which will be returned in py side: myapp = MyGuyApp () returnValue = myapp . run ()","title":"self.exit( returnValue=None )"},{"location":"demo/","text":"Demo Mode Server Server's mode is more prompt for demo (Here on glitch.com ): a simple guy's app ( Play with sources ) a guy's app serving a vuejs/sfc UI ( Play with sources ) Mode App/cef If you want to try app/cef mode, just test the test*.py files here on your computer. Here is one : On Ubuntu On Android10 Mode App on android You can try the bubble killer's game sources ( here is on the playstore ) Or, the less interesting howto demo apk, on the playstore","title":"Demo"},{"location":"demo/#demo","text":"","title":"Demo"},{"location":"demo/#mode-server","text":"Server's mode is more prompt for demo (Here on glitch.com ): a simple guy's app ( Play with sources ) a guy's app serving a vuejs/sfc UI ( Play with sources )","title":"Mode Server"},{"location":"demo/#mode-appcef","text":"If you want to try app/cef mode, just test the test*.py files here on your computer. Here is one : On Ubuntu On Android10","title":"Mode App/cef"},{"location":"demo/#mode-app-on-android","text":"You can try the bubble killer's game sources ( here is on the playstore ) Or, the less interesting howto demo apk, on the playstore","title":"Mode App on android"},{"location":"howto_build_apk_android/","text":"How to build an APK for Android You will need to install kivy and buildozer ! This How-to assume that you use a linux platform ;-) Install the tools sudo apt install python3-kivy zipalign python3 -m pip install --upgrade buildozer Note : you should install the kivy version which belongs to your platform For buildozer : you can pip it ! Create your first Guy's apk Create an empty folder, and from a console inside the folder Get guy.py module (needed, to be embedded in apk) wget https://raw.githubusercontent.com/manatlan/guy/master/guy.py Get an icon/splashscreen for the apk wget https://raw.githubusercontent.com/manatlan/guy/master/android/data/logo.png Create the file buildozer.spec ( specs ), with this content: [app] title = Guy Demo package.name = com.guy package.domain = demo source.dir = . source.include_exts = version = 0.1 requirements = python3,kivy,tornado presplash.filename = %(source.dir)s/logo.png icon.filename = %(source.dir)s/logo.png orientation = portrait osx.python_version = 3 osx.kivy_version = 1.9.1 fullscreen = 0 android.permissions = INTERNET android.api = 28 android.ndk = 17c android.arch = arm64-v8a [buildozer] log_level = 2 warn_on_root = 1 (You can setup your android.permissions according your needs (separated by comma \" , \")) Create the file main.py (your file app should be named main.py , it's a buildozer's request): from guy import Guy class Hello ( Guy ): __doc__ = \"\"\"<button onclick=\"self.test().then( function(x) {document.body.innerHTML+=x})\">test</button>\"\"\" def test ( self ): return \"hello world\" if __name__ == \"__main__\" : app = Hello () app . run () Run the app in your environment ... to be sure it works as is python3 main.py Connect your smartphone with an usb cable to your computer (and allow file transfer mode in your android), and run: buildozer android debug deploy run First run is very long (more than 20min on my computer), second run is a lot faster (10sec) ... Your android will prompt you to authorize the installation : check yes ... Your app should start on the phone ;-) Info But, recent android, doesn't allow to use http traffic (error ERR_CLEARTEXT_NOT_PERMITTED ). So you will need to authorize \"Clear Text Traffic\" for your APK. It's not a problem, or a security risk (the app will only listening http on localhost), see next section. Authorize \"Clear Text Traffic\" in your APK You will need to authorize your app to access the embedded python http server, which serve on localhost \"http\" only. To do that, you must enable \"Clear Text Traffic\" in your \"AndroidManifest.xml\". Using buildozer, you can change the template which will be used to generate the original. Open your file .buildozer/android/platform/build/dists/<<package.name>>/templates/AndroidManifest.tmpl.xml (.buildozer/android/platform/build/dists/com.guy/templates/AndroidManifest.tmpl.xml) Add android:usesCleartextTraffic=\"true\" in tag <application> in AndroidManifest.tmpl.xml Search the tag <application> which look like this : <application android:label= \"@string/app_name\" android:icon= \"@drawable/icon\" android:allowBackup= \"{{ args.allow_backup }}\" android:theme= \"@android:style/Theme.NoTitleBar{% if not args.window %}.Fullscreen{% endif %}\" android:hardwareAccelerated= \"true\" > And change it to : <application android:label= \"@string/app_name\" android:icon= \"@drawable/icon\" android:usesCleartextTraffic= \"true\" android:allowBackup= \"{{ args.allow_backup }}\" android:theme= \"@android:style/Theme.NoTitleBar{% if not args.window %}.Fullscreen{% endif %}\" android:hardwareAccelerated= \"true\" > Tip If you modify buildozer.spec , it can alter the manifest. So you will need to reproduce this step ! Alternatively, you can use this sed command to do it, in one line sed -i 's/<application android:label/<application android:usesCleartextTraffic=\"true\" android:label/g' .buildozer/android/platform/build/dists/com.guy/templates/AndroidManifest.tmpl.xml Deploy in android's playstore You will need to sign your apk, before uploading it. You will need OpenJDK tools ! To release your apk: buildozer android release It will produce an apk file ... but the command ends with an error \"FileNotFoundError: [Errno 2] No such file or directory ...\"\" In fact, the APK release is here : \".buildozer/android/platform/build/dists/com.guy/build/outputs/apk/release/com.guy-release-unsigned.apk\" Just copy it, in the bin folder: cp .buildozer/android/platform/build/dists/com.guy/build/outputs/apk/release/com.guy-release-unsigned.apk bin/ To sign your APK, you will need to create your self-signed key ! keytool -genkey -v -keystore my-app.keystore -alias cb-play -keyalg RSA -keysize 2048 -validity 10000 When you get your keystore (file my-app.keystore ), you can sign the apk, by doing : jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore ./my-app.keystore ./bin/com.guy-release-unsigned.apk cb-play When it's done, just zipalign the apk, like that : zipalign -v 4 ./bin/com.guy-release-unsigned.apk ./bin/myapp.apk Now, your apk myapp.apk can be distributed, or uploaded to playstore . Info Here is the myapp.apk (~13Mo) , that I have released when following this howto. Succesfully installed and tested on android9 & android10 ! And here is this apk on the playstore ! Known Limitations The android's BACK KEY does nothing ;-( (NEED TO IMPROVE THAT). You should provide a way to let the user quit your app (by calling self.exit() ) If you plan to use vbuild (to compile vue sfc components in html), to generate html. You can't use PyComponents . And you will need vbuild >= 0.8.1. (the module pscript can't be embedded in an apk) BTW, Some python modules can't be embedded in an APK : use pure python modules ! When you use html in docstring in a guy class. You will need to prefix your docstring like this __doc__=\"\"\"html\"\"\" . Because buildozer remove real docstrings from py files. Don't try to embed a GuyApp which are runned by app.runCef() or app.serve() ... only app.run() will work ;-) Sources https://linuxfr.org/news/minipy-un-serveur-python-dans-son-android","title":"Release an APK/android"},{"location":"howto_build_apk_android/#how-to-build-an-apk-for-android","text":"You will need to install kivy and buildozer ! This How-to assume that you use a linux platform ;-)","title":"How to build an APK for Android"},{"location":"howto_build_apk_android/#install-the-tools","text":"sudo apt install python3-kivy zipalign python3 -m pip install --upgrade buildozer Note : you should install the kivy version which belongs to your platform For buildozer : you can pip it !","title":"Install the tools"},{"location":"howto_build_apk_android/#create-your-first-guys-apk","text":"Create an empty folder, and from a console inside the folder Get guy.py module (needed, to be embedded in apk) wget https://raw.githubusercontent.com/manatlan/guy/master/guy.py Get an icon/splashscreen for the apk wget https://raw.githubusercontent.com/manatlan/guy/master/android/data/logo.png Create the file buildozer.spec ( specs ), with this content: [app] title = Guy Demo package.name = com.guy package.domain = demo source.dir = . source.include_exts = version = 0.1 requirements = python3,kivy,tornado presplash.filename = %(source.dir)s/logo.png icon.filename = %(source.dir)s/logo.png orientation = portrait osx.python_version = 3 osx.kivy_version = 1.9.1 fullscreen = 0 android.permissions = INTERNET android.api = 28 android.ndk = 17c android.arch = arm64-v8a [buildozer] log_level = 2 warn_on_root = 1 (You can setup your android.permissions according your needs (separated by comma \" , \")) Create the file main.py (your file app should be named main.py , it's a buildozer's request): from guy import Guy class Hello ( Guy ): __doc__ = \"\"\"<button onclick=\"self.test().then( function(x) {document.body.innerHTML+=x})\">test</button>\"\"\" def test ( self ): return \"hello world\" if __name__ == \"__main__\" : app = Hello () app . run () Run the app in your environment ... to be sure it works as is python3 main.py Connect your smartphone with an usb cable to your computer (and allow file transfer mode in your android), and run: buildozer android debug deploy run First run is very long (more than 20min on my computer), second run is a lot faster (10sec) ... Your android will prompt you to authorize the installation : check yes ... Your app should start on the phone ;-) Info But, recent android, doesn't allow to use http traffic (error ERR_CLEARTEXT_NOT_PERMITTED ). So you will need to authorize \"Clear Text Traffic\" for your APK. It's not a problem, or a security risk (the app will only listening http on localhost), see next section.","title":"Create your first Guy's apk"},{"location":"howto_build_apk_android/#authorize-clear-text-traffic-in-your-apk","text":"You will need to authorize your app to access the embedded python http server, which serve on localhost \"http\" only. To do that, you must enable \"Clear Text Traffic\" in your \"AndroidManifest.xml\". Using buildozer, you can change the template which will be used to generate the original. Open your file .buildozer/android/platform/build/dists/<<package.name>>/templates/AndroidManifest.tmpl.xml (.buildozer/android/platform/build/dists/com.guy/templates/AndroidManifest.tmpl.xml) Add android:usesCleartextTraffic=\"true\" in tag <application> in AndroidManifest.tmpl.xml Search the tag <application> which look like this : <application android:label= \"@string/app_name\" android:icon= \"@drawable/icon\" android:allowBackup= \"{{ args.allow_backup }}\" android:theme= \"@android:style/Theme.NoTitleBar{% if not args.window %}.Fullscreen{% endif %}\" android:hardwareAccelerated= \"true\" > And change it to : <application android:label= \"@string/app_name\" android:icon= \"@drawable/icon\" android:usesCleartextTraffic= \"true\" android:allowBackup= \"{{ args.allow_backup }}\" android:theme= \"@android:style/Theme.NoTitleBar{% if not args.window %}.Fullscreen{% endif %}\" android:hardwareAccelerated= \"true\" > Tip If you modify buildozer.spec , it can alter the manifest. So you will need to reproduce this step ! Alternatively, you can use this sed command to do it, in one line sed -i 's/<application android:label/<application android:usesCleartextTraffic=\"true\" android:label/g' .buildozer/android/platform/build/dists/com.guy/templates/AndroidManifest.tmpl.xml","title":"Authorize \"Clear Text Traffic\" in your APK"},{"location":"howto_build_apk_android/#deploy-in-androids-playstore","text":"You will need to sign your apk, before uploading it. You will need OpenJDK tools ! To release your apk: buildozer android release It will produce an apk file ... but the command ends with an error \"FileNotFoundError: [Errno 2] No such file or directory ...\"\" In fact, the APK release is here : \".buildozer/android/platform/build/dists/com.guy/build/outputs/apk/release/com.guy-release-unsigned.apk\" Just copy it, in the bin folder: cp .buildozer/android/platform/build/dists/com.guy/build/outputs/apk/release/com.guy-release-unsigned.apk bin/ To sign your APK, you will need to create your self-signed key ! keytool -genkey -v -keystore my-app.keystore -alias cb-play -keyalg RSA -keysize 2048 -validity 10000 When you get your keystore (file my-app.keystore ), you can sign the apk, by doing : jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore ./my-app.keystore ./bin/com.guy-release-unsigned.apk cb-play When it's done, just zipalign the apk, like that : zipalign -v 4 ./bin/com.guy-release-unsigned.apk ./bin/myapp.apk Now, your apk myapp.apk can be distributed, or uploaded to playstore . Info Here is the myapp.apk (~13Mo) , that I have released when following this howto. Succesfully installed and tested on android9 & android10 ! And here is this apk on the playstore !","title":"Deploy in android's playstore"},{"location":"howto_build_apk_android/#known-limitations","text":"The android's BACK KEY does nothing ;-( (NEED TO IMPROVE THAT). You should provide a way to let the user quit your app (by calling self.exit() ) If you plan to use vbuild (to compile vue sfc components in html), to generate html. You can't use PyComponents . And you will need vbuild >= 0.8.1. (the module pscript can't be embedded in an apk) BTW, Some python modules can't be embedded in an APK : use pure python modules ! When you use html in docstring in a guy class. You will need to prefix your docstring like this __doc__=\"\"\"html\"\"\" . Because buildozer remove real docstrings from py files. Don't try to embed a GuyApp which are runned by app.runCef() or app.serve() ... only app.run() will work ;-)","title":"Known Limitations"},{"location":"howto_build_apk_android/#sources","text":"https://linuxfr.org/news/minipy-un-serveur-python-dans-son-android","title":"Sources"},{"location":"howto_build_exe_windows/","text":"How to build an exe for Windows It can be very useful to distribute and exe on Microsoft Windows platforms. By the way, you can freeze an executable on all platforms. But the following lines are for Windows platform. You will need pyinstaller ! A \"light\" one, with the need of chrome on the host (Who doesn't have chrome on its computer ?!) If yours users have chrome installed. It's the best option : the exe will reuse the installed chrome in \"app mode\". The exe will be lighter (6mo min) It's the best option for app.run() or app.serve() modes in your main py file. pyinstaller.exe YourGuyApp.py --noupx --onefile --noconsole --exclude-module cefpython3 --add-data=\"static;static\" Notes: noupx : because, with upx it gives me errors ;-) onefile : to embed all needed runtime files. noconsole : like you want ... exclude-module cefpython3 : So you will need to have chrome on the host machine to be able to run the exe. add-data=\"static;static\" : to embed yours static file for rendering (css, images ...) A full one ; all included If you target an unknow windows computer, perhaps you should embed a chrome in the exe. It's possible with cefpython3 module. Install cefpython python3 -m pip install cefpython3 And change your app.run() into app.runCef() in your main py file. pyinstaller.exe YourGuyApp.py --noupx --onefile --noconsole --add-data=\"static;static\" Notes: your exe will be bigger (60mo min) noupx : because, with upx it gives me errors ;-) onefile : to embed all needed runtime files. noconsole : like you want ... add-data=\"static;static\" : to embed yours static file for rendering (css, images ...)","title":"Freeze exe/windows"},{"location":"howto_build_exe_windows/#how-to-build-an-exe-for-windows","text":"It can be very useful to distribute and exe on Microsoft Windows platforms. By the way, you can freeze an executable on all platforms. But the following lines are for Windows platform. You will need pyinstaller !","title":"How to build an exe for Windows"},{"location":"howto_build_exe_windows/#a-light-one-with-the-need-of-chrome-on-the-host","text":"(Who doesn't have chrome on its computer ?!) If yours users have chrome installed. It's the best option : the exe will reuse the installed chrome in \"app mode\". The exe will be lighter (6mo min) It's the best option for app.run() or app.serve() modes in your main py file. pyinstaller.exe YourGuyApp.py --noupx --onefile --noconsole --exclude-module cefpython3 --add-data=\"static;static\" Notes: noupx : because, with upx it gives me errors ;-) onefile : to embed all needed runtime files. noconsole : like you want ... exclude-module cefpython3 : So you will need to have chrome on the host machine to be able to run the exe. add-data=\"static;static\" : to embed yours static file for rendering (css, images ...)","title":"A \"light\" one, with the need of chrome on the host"},{"location":"howto_build_exe_windows/#a-full-one-all-included","text":"If you target an unknow windows computer, perhaps you should embed a chrome in the exe. It's possible with cefpython3 module. Install cefpython python3 -m pip install cefpython3 And change your app.run() into app.runCef() in your main py file. pyinstaller.exe YourGuyApp.py --noupx --onefile --noconsole --add-data=\"static;static\" Notes: your exe will be bigger (60mo min) noupx : because, with upx it gives me errors ;-) onefile : to embed all needed runtime files. noconsole : like you want ... add-data=\"static;static\" : to embed yours static file for rendering (css, images ...)","title":"A full one ; all included"},{"location":"howto_build_whl_package/","text":"How to build a WHL package for pypi You can create a pypi-package to distribute your app/tool ! It's really easy with poetry First of all : create your package, from a console : poetry new myapp Edit your newly myapp/pyproject.toml to match : [tool.poetry] name = \"myapp\" version = \"0.1.0\" description = \"\" authors = [ \"you <you@gmail.com>\" ] [ tool . poetry . scripts ] # <-- create a 'myapp' command myapp = 'myapp:main' [tool.poetry.dependencies] python = \"^3.7\" guy = \"^0.4\" # <-- add a dependency to guy [tool.poetry.dev-dependencies] pytest = \"^3.0\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" I've setuped a console script in section [tool.poetry.scripts] . And I've added a dependency to guy in [tool.poetry.dependencies] . Now, you just need to add the entry point main() (and the core app ;-) in your package ... Edit the file myapp/myapp/__init__.py like that : __version__ = '0.1.0' from guy import Guy class App ( Guy ): \"\"\" hello \"\"\" def main (): # <-- the entry point for the script !! App () . run () if __name__ == \"__main__\" : main () Info If you plan to declare your html in a static html file : just put your static datas in the myapp/myapp/static folder, and they will be be embbeded in the package (as package_data ). Guy (>=0.4.0) will be able to resolve them in the installed package. And you are ! Just build your package (place you in the folder where pyproject.toml sits) poetry build And it's done ! You can distribute your package ( dist/myapp-0.1.0-py3-none-any.whl ), publish it to pypi.org ... ... or install it : python3.7 -m pip install --user --force dist/myapp-0.1.0-py3-none-any.whl","title":"Release a pypi/whl/package"},{"location":"howto_build_whl_package/#how-to-build-a-whl-package-for-pypi","text":"You can create a pypi-package to distribute your app/tool ! It's really easy with poetry First of all : create your package, from a console : poetry new myapp Edit your newly myapp/pyproject.toml to match : [tool.poetry] name = \"myapp\" version = \"0.1.0\" description = \"\" authors = [ \"you <you@gmail.com>\" ] [ tool . poetry . scripts ] # <-- create a 'myapp' command myapp = 'myapp:main' [tool.poetry.dependencies] python = \"^3.7\" guy = \"^0.4\" # <-- add a dependency to guy [tool.poetry.dev-dependencies] pytest = \"^3.0\" [build-system] requires = [ \"poetry>=0.12\" ] build-backend = \"poetry.masonry.api\" I've setuped a console script in section [tool.poetry.scripts] . And I've added a dependency to guy in [tool.poetry.dependencies] . Now, you just need to add the entry point main() (and the core app ;-) in your package ... Edit the file myapp/myapp/__init__.py like that : __version__ = '0.1.0' from guy import Guy class App ( Guy ): \"\"\" hello \"\"\" def main (): # <-- the entry point for the script !! App () . run () if __name__ == \"__main__\" : main () Info If you plan to declare your html in a static html file : just put your static datas in the myapp/myapp/static folder, and they will be be embbeded in the package (as package_data ). Guy (>=0.4.0) will be able to resolve them in the installed package. And you are ! Just build your package (place you in the folder where pyproject.toml sits) poetry build And it's done ! You can distribute your package ( dist/myapp-0.1.0-py3-none-any.whl ), publish it to pypi.org ... ... or install it : python3.7 -m pip install --user --force dist/myapp-0.1.0-py3-none-any.whl","title":"How to build a WHL package for pypi"},{"location":"howto_migrate_from_wuy_to_guy/","text":"How to migrate from wuy ( wuy is the ancestor of guy ) Replace all wuy keyword in your py files, by guy Replace all wuy in html/js files, by guy (for core methods) or self (for those which you have declared in your class) ... see ( client side ) Replace wuy.Window / wuy.Server by guy.Guy .get() & .set() configs are replaced by self.cfg (py side) and guy.cfg (js side) Rename your web folder to static folder, if needed. At launch, get the instance, and apply one of theses methods: instance.run() : for classical \"app mode\" instance.serve() : for classical \"server mode\" From wuy: AppWindow () to guy: app = AppWindow () app . run () Info Here is my biggest wuy's app migration to guy Info if socket close : client will reconnect ! (it will not close the app, like wuy did)","title":"From wuy to guy"},{"location":"howto_migrate_from_wuy_to_guy/#how-to-migrate-from-wuy","text":"( wuy is the ancestor of guy ) Replace all wuy keyword in your py files, by guy Replace all wuy in html/js files, by guy (for core methods) or self (for those which you have declared in your class) ... see ( client side ) Replace wuy.Window / wuy.Server by guy.Guy .get() & .set() configs are replaced by self.cfg (py side) and guy.cfg (js side) Rename your web folder to static folder, if needed. At launch, get the instance, and apply one of theses methods: instance.run() : for classical \"app mode\" instance.serve() : for classical \"server mode\" From wuy: AppWindow () to guy: app = AppWindow () app . run () Info Here is my biggest wuy's app migration to guy Info if socket close : client will reconnect ! (it will not close the app, like wuy did)","title":"How to migrate from wuy"},{"location":"install/","text":"Install As Guy is available in Pypi , simply : $ python3 -m pip install guy Note that Tornado is the unique dependancy. (but you'll need kivy , if you plan to release an android's app) Info The guy >=0.3.9 should fix the know bug ( py3.8 issue ) , with the use of Tornado & python 3.8 on Windows 10 platforms !","title":"Install"},{"location":"install/#install","text":"As Guy is available in Pypi , simply : $ python3 -m pip install guy Note that Tornado is the unique dependancy. (but you'll need kivy , if you plan to release an android's app) Info The guy >=0.3.9 should fix the know bug ( py3.8 issue ) , with the use of Tornado & python 3.8 on Windows 10 platforms !","title":"Install"},{"location":"multiple/","text":"Multiple instances Not like the good old wuy . With guy : you can use multiple guy's instance ! It's the main new feature over wuy . You can declare many Guy's class, and use them in a same app : it's easier to make bigger app ; you can leverage your logic/ui in multiple guy's class component. You can use theses others guy's class, using a simple Navigate to another window Info Note that the 'main instance' refers to the one which starts the loop. This instance will live til its dead (exit). Others guy's instances are (re)created on demand. So, the main instance can be useful to store persistent data during the life of the guy's app. Each instances have always access to the main one, using self.parent . Navigate to another window Consider this guy's app: from guy import Guy class Page2 ( Guy ): \"\"\" <<txt>> <a href=\"/Page1\">go to Page1</a> <a href=\"/\">go to Page1 too !</a> \"\"\" def __init__ ( self , txt ): Guy . __init__ ( self ) self . txt = txt class Page1 ( Guy ): \"\"\" <a href=\"/Page2?txt=Hello\">go to Page2</a> \"\"\" if __name__ == \"__main__\" : app = Page1 () app . run () When the app is started, the Page1 will be rendered, and you can navigate to Page2 , and go back to Page1 . Each page/class is available under its name. The main instance, is the default one, and is available at root ('/') too. BTW, when you are on Page2 , Page1 methods are not available anymore, and vis versa (the other instance is \"dead\", in fact). See testRedirect.py Info All windows share the same socket ! But each instance (on server side) is unique to a client. Since >= 0.5.0, query parameters are used to resolve the constructor signature","title":"Multiple Instance"},{"location":"multiple/#multiple-instances","text":"Not like the good old wuy . With guy : you can use multiple guy's instance ! It's the main new feature over wuy . You can declare many Guy's class, and use them in a same app : it's easier to make bigger app ; you can leverage your logic/ui in multiple guy's class component. You can use theses others guy's class, using a simple Navigate to another window Info Note that the 'main instance' refers to the one which starts the loop. This instance will live til its dead (exit). Others guy's instances are (re)created on demand. So, the main instance can be useful to store persistent data during the life of the guy's app. Each instances have always access to the main one, using self.parent .","title":"Multiple instances"},{"location":"multiple/#navigate-to-another-window","text":"Consider this guy's app: from guy import Guy class Page2 ( Guy ): \"\"\" <<txt>> <a href=\"/Page1\">go to Page1</a> <a href=\"/\">go to Page1 too !</a> \"\"\" def __init__ ( self , txt ): Guy . __init__ ( self ) self . txt = txt class Page1 ( Guy ): \"\"\" <a href=\"/Page2?txt=Hello\">go to Page2</a> \"\"\" if __name__ == \"__main__\" : app = Page1 () app . run () When the app is started, the Page1 will be rendered, and you can navigate to Page2 , and go back to Page1 . Each page/class is available under its name. The main instance, is the default one, and is available at root ('/') too. BTW, when you are on Page2 , Page1 methods are not available anymore, and vis versa (the other instance is \"dead\", in fact). See testRedirect.py Info All windows share the same socket ! But each instance (on server side) is unique to a client. Since >= 0.5.0, query parameters are used to resolve the constructor signature","title":"Navigate to another window"},{"location":"run/","text":"Run your app Admit you've got an app: from guy import Guy class YourApp ( Guy ): ... if __name__ == \"__main__\" : app = YourApp () app . run () #<- this is how to run it ;-) Info Since 0.5.1 versions, you can use autoreload 's mode to help you during dev process (in production : don't set the autoreload to True ) The differents modes Each method starts the loop (and provide the GUI). And when exiting : it returns the exit's returnValue (see js/exit() or py/exit()) app mode Use app.run() Classical mode, on desktop : it uses the installed chrome browser in app mode. (it's the way to run on android too) Optionnal parameters: one: (bool), permit to run just once instance at the same time (if True, running a second one will re-focus to the already runned one), default: False log: (bool) enable logging (client & server side) (don't have any effect on android), default: False autoreload: (bool) autoreload on changes (don't have any effect on android), default: False args: (list) add any additional startup arguments for the browser. Example: args=[\"--autoplay-policy=no-user-gesture-required\"] app.run(one=True, args=[\"--autoplay-policy=no-user-gesture-required\"]) To be able to store things in js/localStorage, you must use the one parameter, to make storage persistent. By default, storage is not persistent, and removed after each use! cef mode Use app.runCef() Special mode for desktop : when you want to provide a standalone app, with all included. You will need cefpython3 ! (and you user don't need to have a chrome/chromum installed) Optionnal parameters: one: (bool), permit to run just once instance at the same time (if True, running a second one will re-focus to the already runned one), default: False log: (bool) enable logging (client & server side), default: False autoreload: (bool) autoreload on changes, default: False To be able to store things in js/localStorage, you must use the one parameter, to make storage persistent. By default, storage is not persistent, and removed after each use! server mode Use app.serve() Server mode, for servers. Optionnal parameters: log: (bool) enable logging (client & server side), default: False port: (number) listening port, default: 8000. open: (bool) open default browser to the client, default: True autoreload: (bool) autoreload on changes, default: False To summarize the choice Just a table to help you to select the best mode for your needs Mode : App Cef Server Your users need chrome to run your app yes no no Works on android/apk yes no no Works on any OS yes yes yes Your script is freezable, on any OS yes yes yes Your script is pip packageable yes yes yes Minimum size of the freezed executable 6mo 60mo 6mo Many clients at same time no no yes Host your app on a server (glitch.com) no no yes Info Pip-packageable is only enabled for guy >= 0.4.0","title":"Run guy's app"},{"location":"run/#run-your-app","text":"Admit you've got an app: from guy import Guy class YourApp ( Guy ): ... if __name__ == \"__main__\" : app = YourApp () app . run () #<- this is how to run it ;-) Info Since 0.5.1 versions, you can use autoreload 's mode to help you during dev process (in production : don't set the autoreload to True )","title":"Run your app"},{"location":"run/#the-differents-modes","text":"Each method starts the loop (and provide the GUI). And when exiting : it returns the exit's returnValue (see js/exit() or py/exit())","title":"The differents modes"},{"location":"run/#app-mode","text":"Use app.run() Classical mode, on desktop : it uses the installed chrome browser in app mode. (it's the way to run on android too) Optionnal parameters: one: (bool), permit to run just once instance at the same time (if True, running a second one will re-focus to the already runned one), default: False log: (bool) enable logging (client & server side) (don't have any effect on android), default: False autoreload: (bool) autoreload on changes (don't have any effect on android), default: False args: (list) add any additional startup arguments for the browser. Example: args=[\"--autoplay-policy=no-user-gesture-required\"] app.run(one=True, args=[\"--autoplay-policy=no-user-gesture-required\"]) To be able to store things in js/localStorage, you must use the one parameter, to make storage persistent. By default, storage is not persistent, and removed after each use!","title":"app mode"},{"location":"run/#cef-mode","text":"Use app.runCef() Special mode for desktop : when you want to provide a standalone app, with all included. You will need cefpython3 ! (and you user don't need to have a chrome/chromum installed) Optionnal parameters: one: (bool), permit to run just once instance at the same time (if True, running a second one will re-focus to the already runned one), default: False log: (bool) enable logging (client & server side), default: False autoreload: (bool) autoreload on changes, default: False To be able to store things in js/localStorage, you must use the one parameter, to make storage persistent. By default, storage is not persistent, and removed after each use!","title":"cef mode"},{"location":"run/#server-mode","text":"Use app.serve() Server mode, for servers. Optionnal parameters: log: (bool) enable logging (client & server side), default: False port: (number) listening port, default: 8000. open: (bool) open default browser to the client, default: True autoreload: (bool) autoreload on changes, default: False","title":"server mode"},{"location":"run/#to-summarize-the-choice","text":"Just a table to help you to select the best mode for your needs Mode : App Cef Server Your users need chrome to run your app yes no no Works on android/apk yes no no Works on any OS yes yes yes Your script is freezable, on any OS yes yes yes Your script is pip packageable yes yes yes Minimum size of the freezed executable 6mo 60mo 6mo Many clients at same time no no yes Host your app on a server (glitch.com) no no yes Info Pip-packageable is only enabled for guy >= 0.4.0","title":"To summarize the choice"},{"location":"server/","text":"Server Side : python guy Basically, you subclass the guy class like this: #!/usr/bin/python3 -u from guy import Guy class Simple ( Guy ): size = ( 400 , 400 ) __doc__ = \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" def test ( self ): print ( \"hello world\" ) And all declared methods will be available on client side . Here there will be a self.test() method in client side. Understand that a guy's class is an html page. Declared methods will be available on client side, and will be directly usable from js side. Rendering the UI The rendering is done after the instanciation of the class : when the client connects, or do a refresh. Rendering with docstring It's the simplest thing : just declare your gui/html in the docstring of your class. class Simple ( Guy ): __doc__ = \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" It's a fast way to release a simple component. But it's not adapted for larger app ;-) Info here is the __doc__ declaration. Which is needed if you want to release a component like that on android (because buildozer seems to remove them, if not prefixed) TODO : talk about template engine ! ( <<var>> replaced by instance/class attributs) Rendering with an html file If you want to separate the UI from the code (best practice). You can put your html in a file named as the class name, in a static folder. It's the preferable way to go, for larger app. Info In this case : you should provide a tag <script src=\"guy.js\"></script> in your html. TODO : talk about template engine ! ( <<var>> replaced by instance/class attributs) Rendering override Sometimes, you need to make more things, and you can do it, by overriding the render(self, path) method of your class. For bigger app : I use vbuild to render vuejs/sfc components. (see starter-guy-vuejs , and demo ) class App ( Guy ): def render ( self , path ): # override default with open ( os . path . join ( path , \"app/APP.html\" ) as fid : buf = fid . read () r = vbuild . render ( os . path . join ( path , \"app/*.vue\" ) ) buf = buf . replace ( \"<!-- TPLS -->\" , r . html ) buf = buf . replace ( \"/* CSS */\" , r . style ) buf = buf . replace ( \"/* JS */\" , r . script ) return buf Info In this case : you should provide a tag <script src=\"guy.js\"></script> in your response. Guy Class Like a normal class : you can override its constructor and set some attributs at this place. Note that, the constructor is called before the rendering : so it's the perfect place to setup some things before rendering. TODO : Talk about returning {script: \"...\"} TODO : Talk about sync/async methods. init(self) Override this method to do thing, when a client is connected. (init method can be sync or async) render(self,path) Override this method to override default rendering (see Rendering override ) path is the path to the data (where static folder sits) If this method is not overriden : it will try to get the html from the __doc__ 's string, if not ... from the static folder ( guy.FOLDERSTATIC ) self.exit( returnValue=None ) Exit the app. If you want to get a \"returnValue\", you can set the returned value, which will be returned in py side: myapp = MyGuyApp () returnValue = myapp . run () cleanup( ...) NEW in 0.7.6 event to define for cleanup things. ( TODO: need better explain ) afterServerStarted( ... ) NEW in 0.7.6 event to define for starting things. ( TODO: need better explain ) async self.emit( event, arg1, arg2 ... ) Call this method to emit an event to all connected clients. It's a non-sense in app or cef mode : because there is only one client. It only got sense in server mode. Prefer the following emitMe to send an event to the gui. async self.emitMe( event, arg1, arg2 ... ) Call this method to emit an event to the connected client. self.parent This attribut contains the main instance (the one which starts all (which done .run() )). If it's None , you are in the main instance. async self.js With this wrapping object, you can call js method (from the connected client) from py side, and get back a returned value : name = await self . js . prompt ( \"what's your name ?\" ) Notes: It can throw a guy.JSException if something is wrong on js side! On py side; you'll need to await the call, even if you don't need to get back the returned value. On js side; your js method can be sync or async. But your method needs to be in window scope. Info Only available for guy >= 0.4.3 self.cfg A place to get/set vars, which will be stored on server side, in a config.json file, where the main executable is runned. (if the guy'app is embedded in a pip/package, the config file will be stored in `~/.<package_name>.json ) To set a var 'name', in py side : self . cfg . name = \"Elton\" To get a var 'name', in py side : name = self . cfg . name size With this class attribut you can specify the size of your window. This is a non-sense, in server mode. Because, it's the client/browser which determine the size of its tab. This is a non-sense, when runned on android. Because the window is the full screen. class Simple ( Guy ): \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" size = ( 400 , 400 ) class Simple ( guy . Guy ): \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" size = guy . FULLSCREEN Info Size may be relevant for the main window (the first started). It has no effect after a navigation or for embedded window. Static content guy will serve everything that is contained in a static folder, as static content. It's really useful, when you don't embbed your html in the docstring of the class, or if you need static content like images, css files, etc ... Important Static content should contain dots (\".\") in filename ! If not; current guy's version consider it must be served as dynamic content ! (it may change in the near future) This static folder should be in the same path as your main guy class, like this : \u251c\u2500\u2500 main.py <- Contains class Index(guy.Guy) \u2514\u2500\u2500 static \u2514\u2500\u2500 Index.html It's possible to use another for this folder, by setting guy.FOLDERSTATIC = \"ui\" at start. Hook http Guy provides an http decorator to handle specific http requests. It can be useful for a lot of things. from guy import http @http ( \"/item/(\\d+)\" ) def getItem ( web , number ): web . write ( \"item %s \" % number ) web is a Tornado's RequestHandler TODO : talk about returning a guy window (for beautiful url) Important The url catched by the hook http, can't contain dots (\".\") ! If there is a dot; current guy's version consider it must be served as static content ! (it may change in the near future)","title":"Server side"},{"location":"server/#server-side-python-guy","text":"Basically, you subclass the guy class like this: #!/usr/bin/python3 -u from guy import Guy class Simple ( Guy ): size = ( 400 , 400 ) __doc__ = \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" def test ( self ): print ( \"hello world\" ) And all declared methods will be available on client side . Here there will be a self.test() method in client side. Understand that a guy's class is an html page. Declared methods will be available on client side, and will be directly usable from js side.","title":"Server Side : python guy"},{"location":"server/#rendering-the-ui","text":"The rendering is done after the instanciation of the class : when the client connects, or do a refresh.","title":"Rendering the UI"},{"location":"server/#rendering-with-docstring","text":"It's the simplest thing : just declare your gui/html in the docstring of your class. class Simple ( Guy ): __doc__ = \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" It's a fast way to release a simple component. But it's not adapted for larger app ;-) Info here is the __doc__ declaration. Which is needed if you want to release a component like that on android (because buildozer seems to remove them, if not prefixed) TODO : talk about template engine ! ( <<var>> replaced by instance/class attributs)","title":"Rendering with docstring"},{"location":"server/#rendering-with-an-html-file","text":"If you want to separate the UI from the code (best practice). You can put your html in a file named as the class name, in a static folder. It's the preferable way to go, for larger app. Info In this case : you should provide a tag <script src=\"guy.js\"></script> in your html. TODO : talk about template engine ! ( <<var>> replaced by instance/class attributs)","title":"Rendering with an html file"},{"location":"server/#rendering-override","text":"Sometimes, you need to make more things, and you can do it, by overriding the render(self, path) method of your class. For bigger app : I use vbuild to render vuejs/sfc components. (see starter-guy-vuejs , and demo ) class App ( Guy ): def render ( self , path ): # override default with open ( os . path . join ( path , \"app/APP.html\" ) as fid : buf = fid . read () r = vbuild . render ( os . path . join ( path , \"app/*.vue\" ) ) buf = buf . replace ( \"<!-- TPLS -->\" , r . html ) buf = buf . replace ( \"/* CSS */\" , r . style ) buf = buf . replace ( \"/* JS */\" , r . script ) return buf Info In this case : you should provide a tag <script src=\"guy.js\"></script> in your response.","title":"Rendering override"},{"location":"server/#guy-class","text":"Like a normal class : you can override its constructor and set some attributs at this place. Note that, the constructor is called before the rendering : so it's the perfect place to setup some things before rendering. TODO : Talk about returning {script: \"...\"} TODO : Talk about sync/async methods.","title":"Guy Class"},{"location":"server/#initself","text":"Override this method to do thing, when a client is connected. (init method can be sync or async)","title":"init(self)"},{"location":"server/#renderselfpath","text":"Override this method to override default rendering (see Rendering override ) path is the path to the data (where static folder sits) If this method is not overriden : it will try to get the html from the __doc__ 's string, if not ... from the static folder ( guy.FOLDERSTATIC )","title":"render(self,path)"},{"location":"server/#selfexit-returnvaluenone","text":"Exit the app. If you want to get a \"returnValue\", you can set the returned value, which will be returned in py side: myapp = MyGuyApp () returnValue = myapp . run ()","title":"self.exit( returnValue=None )"},{"location":"server/#cleanup","text":"NEW in 0.7.6 event to define for cleanup things. ( TODO: need better explain )","title":"cleanup( ...)"},{"location":"server/#afterserverstarted","text":"NEW in 0.7.6 event to define for starting things. ( TODO: need better explain )","title":"afterServerStarted( ... )"},{"location":"server/#async-selfemit-event-arg1-arg2","text":"Call this method to emit an event to all connected clients. It's a non-sense in app or cef mode : because there is only one client. It only got sense in server mode. Prefer the following emitMe to send an event to the gui.","title":"async self.emit( event, arg1, arg2 ... )"},{"location":"server/#async-selfemitme-event-arg1-arg2","text":"Call this method to emit an event to the connected client.","title":"async self.emitMe( event, arg1, arg2 ... )"},{"location":"server/#selfparent","text":"This attribut contains the main instance (the one which starts all (which done .run() )). If it's None , you are in the main instance.","title":"self.parent"},{"location":"server/#async-selfjs","text":"With this wrapping object, you can call js method (from the connected client) from py side, and get back a returned value : name = await self . js . prompt ( \"what's your name ?\" ) Notes: It can throw a guy.JSException if something is wrong on js side! On py side; you'll need to await the call, even if you don't need to get back the returned value. On js side; your js method can be sync or async. But your method needs to be in window scope. Info Only available for guy >= 0.4.3","title":"async self.js"},{"location":"server/#selfcfg","text":"A place to get/set vars, which will be stored on server side, in a config.json file, where the main executable is runned. (if the guy'app is embedded in a pip/package, the config file will be stored in `~/.<package_name>.json ) To set a var 'name', in py side : self . cfg . name = \"Elton\" To get a var 'name', in py side : name = self . cfg . name","title":"self.cfg"},{"location":"server/#size","text":"With this class attribut you can specify the size of your window. This is a non-sense, in server mode. Because, it's the client/browser which determine the size of its tab. This is a non-sense, when runned on android. Because the window is the full screen. class Simple ( Guy ): \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" size = ( 400 , 400 ) class Simple ( guy . Guy ): \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" size = guy . FULLSCREEN Info Size may be relevant for the main window (the first started). It has no effect after a navigation or for embedded window.","title":"size"},{"location":"server/#static-content","text":"guy will serve everything that is contained in a static folder, as static content. It's really useful, when you don't embbed your html in the docstring of the class, or if you need static content like images, css files, etc ... Important Static content should contain dots (\".\") in filename ! If not; current guy's version consider it must be served as dynamic content ! (it may change in the near future) This static folder should be in the same path as your main guy class, like this : \u251c\u2500\u2500 main.py <- Contains class Index(guy.Guy) \u2514\u2500\u2500 static \u2514\u2500\u2500 Index.html It's possible to use another for this folder, by setting guy.FOLDERSTATIC = \"ui\" at start.","title":"Static content"},{"location":"server/#hook-http","text":"Guy provides an http decorator to handle specific http requests. It can be useful for a lot of things. from guy import http @http ( \"/item/(\\d+)\" ) def getItem ( web , number ): web . write ( \"item %s \" % number ) web is a Tornado's RequestHandler TODO : talk about returning a guy window (for beautiful url) Important The url catched by the hook http, can't contain dots (\".\") ! If there is a dot; current guy's version consider it must be served as static content ! (it may change in the near future)","title":"Hook http"},{"location":"simplest/","text":"The simplest guy app could look like this #!/usr/bin/python3 -u from guy import Guy class Simple ( Guy ): \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" def test ( self ): print ( \"hello world\" ) if __name__ == \"__main__\" : app = Simple () app . run () Will run an app mode . And can be runned on any OS (android, windows, *nix, mac/iOS, ...) Info If you want to act as a cef instance, replace app.run() by app.runCef() If you want to act as a http server, replace app.run() by app.serve()","title":"Example"},{"location":"simplest/#the-simplest-guy-app-could-look-like-this","text":"#!/usr/bin/python3 -u from guy import Guy class Simple ( Guy ): \"\"\"<button onclick=\"self.test()\">test</button>\"\"\" def test ( self ): print ( \"hello world\" ) if __name__ == \"__main__\" : app = Simple () app . run () Will run an app mode . And can be runned on any OS (android, windows, *nix, mac/iOS, ...) Info If you want to act as a cef instance, replace app.run() by app.runCef() If you want to act as a http server, replace app.run() by app.serve()","title":"The simplest guy app could look like this"}]}